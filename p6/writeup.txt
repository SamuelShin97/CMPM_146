Trevor Jordy
Samuel Shin


In the implementation of our Grid, we used single point crossover using a random crossover point within the generate_children function. This would result in two different genomes from self and other, and would return which ever one had the higher fitness. 
For selection, we used tournament selection and roulette wheel selection. Half of our results would be filled with roulette, and the other half tournament. The selection of these two methods in combination allowed for more varied results. Tournament selection would compare two different levels and pick the better one; doing this multiple times and then returning the overall winner. The competitors for tournament selection are picked at random such that our levels do not always make the same level design choices. 

We set our mutation rate to 10%, which upon testing seemed to produce good results. We added many constraints to help guide the design of the level. Our random_individual function was modified to avoid spawning things at the edges of the map that interfered with mario and the flag, as well as prevented it from spawning objects into the sky and other constrains that we also put into the mutation function. We extended the options list to weight the different choices and better reflect which ones we hoped to see more often. To reinforce this, within the mutate function we did a similar thing again, making a list that would be picked from randomly upon replacement. In addition to this we prevented spawning of blocks and other objects in the sky, and restricted the ground to be nothing but "X" and "-", floor/platform and blank space. We added constraints regarding pipes to prevent them from flying in the sky or hovering over gaps. We also made sure that the pipes would not reach a height that was impossible for Mario to jump over. Even though the ground was restricted to only “X” and “-“ tiles, a pipe could override this and pipe into the floor if it wants to. We also made it so that there can’t be pipes next to each other so they don’t overlap with one another for aesthetic purposes. Also, if a top is generated at an appropriate height, it will generate a pipe piece below it and eventually create a pipe all the way down to the floor. And pipes will always be capped off and appropriate heights for Mario. One very important change we made was extending gaps that mario could not fit in. We noticed an issue with maps having many one-tile gaps between platforms that mario could not fit in, making large portions of the level inaccessible. To prevent this, we found these gaps and extended them to be large enough for mario to fit in. This greatly increased how fun the levels were, as it created more paths mario could take around the level. We also had trouble with the flag generation, so we slapped it back in mutation so every stage would guarantee to have a flag. 
We tweaked the fitness values, hoping to promote more white space to counter act the often very crowded feeling many of the levels had as we previously generated too many blocks and not enough blank space. We rewarded the algorithm for picking more blank area. 

The mutation function of individual_de only mutates if it fits the criteria, and initially only mutates at a 10% chance. We raised this mutation rate to speed up the process of creating a level as it often took many iterations to get a level sufficiently exciting enough. The mutation function will grab one element from the genome and use its x value and its type. It will use its series of if statements to execute the code corresponding to the element's type. An example of this is if the type is 3_coin, this will grab run the coin's code, which uses the y coordinate and a random number and do comparisons. There will be positional changes to the x and y coordinates of this object based on what range the number is in. Other elements have other custom behaviors within their if statements. Question mark blocks will have special code to determine whether there is a powerup inside.  The generate_children function uses single point crossover with a random point that is split between 2 genomes. It then mutates and returns both, unlike our Grid which only uses the best one. We added constrains into calculate_fitness to help create an optimal map. In addition to the already existing conditions, we penalized having single lone blocks on their own, as maps will often have many one-block islands that make the map look scattered with no platforms longer than a block. We also penalized having spaces of only one tile size, as there would often be a space surrounded completely by platform blocks, making it inaccessible. It would be better for these blocks to be filled in, as it looks much worse to have random holes in what could be solid terrain. We also penalized having too many enemies in a row, while promoted having coins in a row. 

Generations: 16
Seconds: ~354.2
Our favorite level to play came after we finally added in the constraint in Grid that mutated any single tile empty spaces into at least two-tiles spaces that mario could fit in. This opened up whole new realms of possibilities, and dug tons of passageways through what used to be an overcrowded map. This level turned out particularly nicely. The pipes looked clean and served as good obstacles to maneuver over.  It has an "easier" (still took me a few tries) upper level, and a more dangerous, coin-filled passageway that digs beneath and creates many branching tunnel passages. Almost all of the coins on the level can be collected without dying, for anyone who wants a true challenge of trying to pick them all out. It is challenging yet not impossible, and has plenty of spacing for mario to be able to comfortably get through, though not without having to first plan his path ahead. It was very pleasing to have the algorithm finally deliver on genuinely fun levels consistently. 

We do not wish to participate in the competition.
