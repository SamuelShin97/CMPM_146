"""Samuel Shin, sayshin@ucsc.edu, 1510580Partner: Jessie Aniguid, janiguid@ucsc.edu, 1538200"""from math import inf,sqrtfrom heapq import heappop, heappush, heapifydef find_path (source_point, destination_point, mesh):    """    Searches for a path from source_point to destination_point through the mesh    Args:        source_point: starting point of the pathfinder        destination_point: the ultimate goal the pathfinder must reach        mesh: a dictionary with two keys: 'boxes' and 'adj'            mesh[boxes]:list of non-overlapping white rectangular boxes                        nodes in a graph            mesh[adj]:dictionary that maps boxes to other boxes                      essentially contains a box's neighbours    Returns:        A path (list of points) from source_point to destination_point if exists        A list of boxes explored by the algorithm    """    path = []    boxes = {}        start_box_found = False    destination_box_found = False    start_box = None    destination_box = None    for i in mesh['boxes']:        current_box = i        current_box_y1 = current_box[0]        current_box_y2 = current_box[1]        current_box_x1 = current_box[2]        current_box_x2 = current_box[3]        #print('current node: ')        #print(i)        #if y value of starting point is in between a box's upper y coordinate and lower y coordinate        if(current_box_y1 <= source_point[0] and current_box_y2 >= source_point[0] and start_box_found == False):            #if x value of starting point is in between a box's leftmost x coordinate and rightmost y coordinate            if(current_box_x1 <= source_point[1] and source_point[1] <= current_box_x2):                #print('found source box')                #print(i)                start_box = i                start_box_found = True                        #same as above        if(current_box_y1 < destination_point[0] and current_box_y2 > destination_point[0]  and destination_box_found == False):            if(current_box_x1 < destination_point[1] and destination_point[1] < current_box_x2):                #print('found destination box')                #print(i)                destination_box = i                destination_box_found = True        if(destination_box_found == True and start_box_found == True):            break    #print('source point: ' + str(source_point))    #print('destination point: ' + str(destination_point))    #print('start box: ' + str(start_box))    #print('destination box: ' + str(destination_box))    distance_table = BFS(mesh, mesh['adj'], start_box, destination_box, source_point, destination_point)    return bidir_A_star(start_box, destination_box, mesh['boxes'], mesh['adj'], distance_table, source_point, destination_point)    #return BFS(mesh, mesh['adj'], start_box, destination_box, source_point, destination_point)    #return path, boxes.keys()def A_star(start_box, destination_box, graph, adj, distance_table, source_point, destination_point):    """ Searches for a minimal cost path through a graph using Dijkstra's algorithm.    Args:        initial_position: The initial cell from which the path extends.        destination: The end location for the path.        graph: A loaded level, containing walls, spaces, and waypoints.        adj: An adjacency function returning cells adjacent to a given cell as well as their respective edge costs.    Returns:        If a path exits, return a list containing all cells from initial_position to destination.        Otherwise, return None.    """    #pass    if start_box is None:        print('No Path!')        return [], []    if (start_box == destination_box):        #print('bfs path' + str(start_box))        return [(source_point, destination_point)], [start_box]    queue = []    dist = {}    prev = {}    heappush(queue, (0, start_box)) #push the starting position into the queue    dist[start_box] = 0    current_point = source_point    points = {}    points[start_box] = source_point    list_points = []    while(queue):        current_dist, current_box = heappop(queue)         current_point = points[current_box]        if current_box == destination_box:            n = destination_box            path = []            path.append(n)            while n is not start_box:                path.insert(0, prev[n])                n = prev[n]            #print('dfs path: ' + str(path))            #print('len of path: ' + str(len(path)))            list_points.insert(0, ((source_point), (points[path[0]])))            for b in range(0, len(path) - 1):                list_points.append((points[path[b]], points[path[b + 1]]))            list_points.append(((points[path[len(path) - 1]]), (destination_point)))            return list_points, path        else:            #box is the x,y coordinates for the neighbor we are looking at and cost is the cost of the edge joining the two points            closes_point = None            for box in adj[current_box]:                 next_box = box                x1 = box[2]                x2 = box[3]                y1 = box[0]                y2 = box[1]                            if(current_box[0] == y2): #if the box to go to is above current box                    px = max(min(current_point[1], x2), x1)                    closest_point = (y2, px)                elif(current_box[1] == y1): #if the box to go to is below current box                    px = max(min(current_point[1], x2), x1)                    closest_point = (y1, px)                elif(current_box[3] == x1): #if the box to go to is to the right current box                    py = max(min(current_point[0], y2), y1)                    closest_point = (py, x1)                elif(current_box[2] == x2): #if the box to go to is to the left current box                    py = max(min(current_point[0], y2), y1)                    closest_point = (py, x2)                                pathcost = current_dist + calculate_distance((closest_point), (destination_point))                if box not in dist or pathcost < dist[box]:                    points[box] = closest_point                    dist[box] = pathcost                    heappush(queue, (pathcost, box))                    prev[box] = current_box    print('No Path!')              return [], []def bidir_A_star(start_box, destination_box, graph, adj, distance_table, source_point, destination_point):    """ Searches for a minimal cost path through a graph using Dijkstra's algorithm.    Args:        initial_position: The initial cell from which the path extends.        destination: The end location for the path.        graph: A loaded level, containing walls, spaces, and waypoints.        adj: An adjacency function returning cells adjacent to a given cell as well as their respective edge costs.    Returns:        If a path exits, return a list containing all cells from initial_position to destination.        Otherwise, return None.    """    #pass    if start_box is None or destination_box is None:        print('No Path!')        return [], []    if (start_box == destination_box):        #print('bfs path' + str(start_box))        return [(source_point, destination_point)], [start_box]    queue = []    dist = {}    dist[start_box] = 0    back_dist = {}    back_dist[destination_box] = 0    forward_prev = {}    forward_prev[start_box] = None    backward_prev = {}    backward_prev[destination_box] = None    heappush(queue, (0, start_box, 'destination')) #push the starting position into the queue    heappush(queue, (0, destination_box, 'start'))        current_point = source_point    points = {}    points[start_box] = source_point    back_points = {}    back_points[destination_box] = destination_point    list_points = []    while(queue):        current_dist, current_box, current_goal = heappop(queue)         if current_goal == 'destination':            current_point = points[current_box]        else:            current_point = back_points[current_box]        if current_box in backward_prev and current_box in forward_prev:            n = current_box            path = []            path.append(n)            while n is not start_box:                path.insert(0, forward_prev[n])                n = forward_prev[n]                #print('first n: ' + str(n))                            n = current_box            while n is not destination_box:                path.append(backward_prev[n])                n = backward_prev[n]                #print('second n: ' + str(n))                                        #print('bidir_A* path: ' + str(path))            #print('len of path: ' + str(len(path)))                        center_index = path.index(current_box)                        for b in range(0, center_index):                list_points.append((points[path[b]], points[path[b + 1]]))            list_points.append(((points[path[center_index]]), back_points[path[center_index]]))                           for c in range(center_index, len(path) - 1):                 list_points.append((back_points[path[c]], back_points[path[c + 1]]))            list_points.append(((back_points[path[len(path) - 1]]), (destination_point)))            return list_points, path        else:            #box is the x,y coordinates for the neighbor we are looking at and cost is the cost of the edge joining the two points            closes_point = None            for box in adj[current_box]:                 next_box = box                x1 = box[2]                x2 = box[3]                y1 = box[0]                y2 = box[1]                            if(current_box[0] == y2): #if the box to go to is above current box                    px = max(min(current_point[1], x2), x1)                    closest_point = (y2, px)                elif(current_box[1] == y1): #if the box to go to is below current box                    px = max(min(current_point[1], x2), x1)                    closest_point = (y1, px)                elif(current_box[3] == x1): #if the box to go to is to the right current box                    py = max(min(current_point[0], y2), y1)                    closest_point = (py, x1)                elif(current_box[2] == x2): #if the box to go to is to the left current box                    py = max(min(current_point[0], y2), y1)                    closest_point = (py, x2)                                                if current_goal == 'destination':                    pathcost = current_dist + calculate_distance((closest_point), (destination_point))                    if box not in dist or pathcost < dist[box]:                        points[box] = closest_point                        dist[box] = pathcost                        heappush(queue, (pathcost, box, 'destination'))                        forward_prev[box] = current_box                elif current_goal == 'start':                    pathcost = current_dist + calculate_distance((closest_point), (source_point))                    if box not in back_dist or pathcost < back_dist[box]:                        back_points[box] = closest_point                        back_dist[box] = pathcost                        heappush(queue, (pathcost, box, 'start'))                        backward_prev[box] = current_box    print('No Path!')              return [], []def BFS(mesh, neighbors, start_box, destination_box, source_point, destination_point):    if start_box is None:        #print('No Path!')        return [], []    if (start_box == destination_box):        #print('bfs path' + str(start_box))        return [(source_point, destination_point)], [start_box]    queue = [start_box]    path = []    parent_path = {}    parent_path[start_box] = None    points = {}    found = False    #print ('inside bfs')    while queue:        current_node = queue.pop(0)        if(current_node == destination_box):            found = True            n = current_node            path.append(n)            while parent_path[n] is not start_box:                path.insert(0, parent_path[n])                n = parent_path[n]            path.insert(0, start_box)            #print('bfs path' + str(path))            break                    for i in neighbors[current_node]:            if(i not in parent_path):                parent_path[i] = current_node                queue.append(i)    if found == True:        points[path[0]] = source_point        closest_point = None        source_box = None        list_points = []        distance_table = {}        for a in range(1, len(path)):            if(a == 1):                s = source_point                source_box = start_box                #print(s)            else:                s = points[path[a - 1]]                source_box = path[a - 1]                #print(s)            x1 = path[a][2]            x2 = path[a][3]            y1 = path[a][0]            y2 = path[a][1]                        if(source_box[0] == y2): #if the box to go to is above current box                px = max(min(s[1], x2), x1)                closest_point = (y2, px)            elif(source_box[1] == y1): #if the box to go to is below current box                px = max(min(s[1], x2), x1)                closest_point = (y1, px)            elif(source_box[3] == x1): #if the box to go to is to the right current box                py = max(min(s[0], y2), y1)                closest_point = (py, x1)            elif(source_box[2] == x2): #if the box to go to is to the left current box                py = max(min(s[0], y2), y1)                closest_point = (py, x2)            #print(closest_point)            points[path[a]] = closest_point                #print(points)        for b in range(0, len(points)):            if(b == len(points) - 1):                list_points.append((points[path[b]], destination_point))            else:                list_points.append((points[path[b]], points[path[b + 1]]))        #euclidean = calculate_distance((1, 1), (3, 3))        #print('euclidean: ' + str(euclidean))        for c in range(0, len(path) - 1):            distance_table[path[c]] = calculate_distance((points[path[c]]), (points[path[c + 1]]))        #print('distance_table: ' + str(distance_table))        return distance_table    else:        #print('No Path!')        return [], []def calculate_distance(point1, point2):    return sqrt(pow((point1[1] - point2[1]), 2) + pow((point1[0] - point2[0]), 2))